using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;

namespace Refit.AspNet
{
    internal class RefitClassSyntaxGenerator
    {
        private const string HttpClientFieldName = "_client";
        private const string MethodImplementationFieldName = "_methods";
        private const string RefitNamespace = nameof(Refit);

        internal static SyntaxTree GenerateSyntax(TemplateInformation templateInfo)
        {
            return SyntaxFactory.SyntaxTree(
                SyntaxFactory.CompilationUnit()
                .WithUsings(GetUsings(templateInfo))
                .WithMembers(GenerateClasses(templateInfo)).NormalizeWhitespace());
        }

        private static SyntaxList<MemberDeclarationSyntax> GenerateClasses(TemplateInformation templateInfo)
        {
            return SyntaxFactory.List<MemberDeclarationSyntax>(
                templateInfo.ClassList.Select(c =>
                {
                    return SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(c.Namespace))
                    .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                        SyntaxFactory.ClassDeclaration($"AutoGenerated{c.InterfaceName}")
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.InternalKeyword))
                        .AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(c.InterfaceName)))
                        .WithMembers(
                            GenerateMethods(c.MethodList)
                                .Add(GenerateConstructor(c))
                                .AddRange(GetClassMembers(c)))
                        ));
                }));
        }

        private static IEnumerable<MemberDeclarationSyntax> GetClassMembers(ClassTemplateInfo c)
        {
            yield return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(
                    SyntaxFactory.ParseTypeName("System.Net.Http.HttpClient")))
                    .AddDeclarationVariables(SyntaxFactory.VariableDeclarator(HttpClientFieldName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                        SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword));

            yield return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(
                    SyntaxFactory.ParseTypeName($"{nameof(System)}.{nameof(System.Collections)}.{nameof(System.Collections.Generic)}.Dictionary<string, System.Func<System.Net.Http.HttpClient, object[], object>>")))
                    .AddDeclarationVariables(SyntaxFactory.VariableDeclarator(MethodImplementationFieldName))
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
                        SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword));
        }

        private static MemberDeclarationSyntax GenerateConstructor(ClassTemplateInfo c)
        {
            return SyntaxFactory.ConstructorDeclaration(
                   $"AutoGenerated{c.InterfaceName}"
            ).WithBody(GenerateConstructorBody(c)).WithParameterList(
                SyntaxFactory.ParseParameterList($"(System.Net.Http.HttpClient client, {RefitNamespace}.{nameof(RequestBuilderImplementation)} requestBuilder)"));
        }

        private static BlockSyntax GenerateConstructorBody(ClassTemplateInfo c)
        {
            string[] statements =
            {
                $"{MethodImplementationFieldName} = requestBuilder.InterfaceHttpMethods.ToDictionary(k => k, requestBuilder.BuildRestResultFuncForMethod);",
                $"{HttpClientFieldName} = client;"
            };

            var items = statements.Select(s => SyntaxFactory.ParseStatement(s));

            return SyntaxFactory.Block(items);
        }

        private static SyntaxList<MemberDeclarationSyntax> GenerateMethods(List<MethodTemplateInfo> methodList)
        {
            return SyntaxFactory.List<MemberDeclarationSyntax>(
                methodList.Select(m =>
                {
                    return SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(m.ReturnType), m.Name)
                    .WithBody(SyntaxFactory.Block(GetMethodBody(m)))
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                    .WithParameterList(SyntaxFactory.ParseParameterList($"({m.ArgumentListWithTypes})"));
                }));
        }

        private static IEnumerable<StatementSyntax> GetMethodBody(MethodTemplateInfo m)
        {
            if (!m.IsRefitMethod)
            {
                const string exceptionMessage = 
                    "Either this method has no Refit HTTP method attribute" + 
                    " or you've used something other than a string literal for the 'path' argument.";

                return new StatementSyntax[]
                {
                    SyntaxFactory.ParseStatement(
                        $"throw new System.NotImplementedException(\"{exceptionMessage}\");")
                };
            }

            string[] statements =
            {
                $"var arguments = new object[]{{ {m.ArgumentList} }};",
                $"return ({m.ReturnType}) {MethodImplementationFieldName}[\"{m.Name}\"]({HttpClientFieldName}, arguments);"
            };

            var items = statements.Select(s => SyntaxFactory.ParseStatement(s));

            return items;
        }

        private static SyntaxList<UsingDirectiveSyntax> GetUsings(TemplateInformation templateInfo)
        {
            return SyntaxFactory.List(
                templateInfo.UsingList.Select(u => SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(u.Item)))
            ).Add(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(typeof(Enumerable).Namespace)));
        }
    }
}